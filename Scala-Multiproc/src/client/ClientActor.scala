package client

import scala.collection.parallel._
import scala.actors._
import scala.actors.Futures._
import scala.actors.Actor._

import server._;
import scala.actors.remote._
import scala.io._
import java.io.File
import scala.actors.remote.RemoteActor._
import util._;
import rpc._;
import rpc.ReturnThreadCount;
import rpc.GenerateNumbers
import rpc.ReturnValues
import scala.annotation.serializable

object ClientActor extends scala.App {

  override def main(args: Array[String]): Unit = {
    try {

      val maxIndividualArraySize: Long = scala.math.pow(2, 26).toLong;

      var dsLocked: Boolean = false;
      var datasetSize: Int = scala.math.pow(2, 26).toInt + 23;

      var ds: Array[Int] = Array();

      implicit def string2Int(s: String): Int = augmentString(s).toInt

      def f(i: Int) = i;

      def ServerList: Array[ServerInformation] = {

        var list: List[ServerInformation] = List[ServerInformation]();

        for (line <- Source.fromFile(new File("clients.txt")).getLines) {

          val split: Array[String] = line.split(" ");

          val server: ServerInformation = new ServerInformation();

          server.sym = Symbol(split(0));
          server.ip = split(1);
          server port = f(split(2));

          list ::= server;
        }

        list.toArray;

      }

      def ActiveClients: Array[ServerInformation] = ServerList.filter(_.isAlive == true)

      RemoteActor.classLoader = getClass().getClassLoader();

      //      cPrint("Client individual array size = " + size.toInt);
      //      cPrint("Client Array Count" + count);
      //      cPrint("Total Numbers generated by client = " + size * (count - 1))
      ServerList.par.foreach(server => {

        //prepends the client ip:port to all print statements
        def cPrint(msg: String) = {
          println(server.ip + ":" + server.port + ": " + msg)
        }

        //remoteActor ! Kill

        var generationsCompleted: Int = 0;

        var localDS: Array[Int] = Array();

        server.node = new Node(server.ip, server.port);
        val remoteActor = select(server.node, server.sym);

        server.SendData = (server == ServerList.head);

        def localDSSize: Int = {
          if (server.clientID == ServerList.head.clientID) {
            cPrint("Found ClientList.head");
            datasetSize / ServerList.size + datasetSize % ServerList.size;
          } else
            datasetSize / ServerList.size
        }

        server.localDSSize = localDSSize;

        var count: Int = (localDSSize / maxIndividualArraySize).toInt + 1;

        val size: Long = {

          if (localDSSize > maxIndividualArraySize) {

            localDSSize / count;

          } else
            localDSSize;
        }

        remoteActor ! IsAlive();

        while (true) {
          receive {
            //once the remote actor says that they're alive, trigger the generation.
            case ReturnThreadCount(threadCount: Int) =>
              {
                cPrint("Registered client " + server.sym + " on " + server.ip + ":" + server.port);

                if (server == ServerList.head) {
                  cPrint("Found ClientList.head");
                }

                server.isAlive = true;

                server.threadCount = threadCount;

                cPrint("Client is alive with Thread count=" + threadCount);

                var totalSize: Long = localDSSize;

                cPrint("Generating Numbers");

                remoteActor ! GenerateNumbers(
                  {
                    (size + totalSize % count).toInt
                  },
                  scala.math.pow(2, 20).toInt);

              }
            case ReturnValues(list: Array[Int]) =>

              cPrint("Adding Array of size:" + list.size + " to dataset.");

              localDS = localDS ++ list;

              cPrint("Dataset size: " + localDS.size);
              generationsCompleted = generationsCompleted + 1;
              cPrint("Generations Complete: " + generationsCompleted + " of " + count);

              if (generationsCompleted < count)
                remoteActor ! GenerateNumbers(
                  {
                    (size).toInt
                  },
                  scala.math.pow(2, 20).toInt);
              else {

                var isAdded = false

                while (!isAdded) {
                  if (!dsLocked) {
                    dsLocked = true;
                    ds = ds ++ localDS;
                    dsLocked = false;
                    isAdded = true;
                  } else
                    Thread.sleep(1000);
                }

                Thread.sleep(1000);
                def sum(xs: List[Array[Int]]): Int = {

                  def inner(xs: List[Array[Int]], accum: Int): Int = {
                    xs match {
                      case x :: tail => inner(tail, accum + x.size)
                      case Nil => accum
                    }
                  }
                  inner(xs, 0)
                }

                var generatedSize = ds.size;

                cPrint("Dataset total size: " + generatedSize)
                cPrint("Requested dataset size:" + datasetSize)

                server.GenerationComplete = true;

                cPrint("Number of Completed Clients: " + ServerList.filter(_.GenerationComplete == true).size)
                cPrint("Number of Active Clients: " + ActiveClients.size)
                
                while (!dsLocked && !server.SortingComplete && ServerList.filter(_.GenerationComplete == true).size == ActiveClients.size) {
                  cPrint("Attempting to Sort Data");

                  if (!dsLocked) {
                    dsLocked = true;
                    SortClientData();
                    server.SortingComplete = true;
                    Thread.sleep(1000);
                  }
                }
                if //(ActiveClients.size < ClientList.size) {
                (false) {
                  //if all of the clients didn't get started
                  // do something to spread the work around some.
                } else {

                }

                //do something with the returned values.
              }
          }

        }
      });

      def SortClientData() = {

        println("Sorting Dataset of size: " + ds.size);

        val aliveClients: Array[ServerInformation] = ServerList.filter(_.isAlive == true)

        aliveClients.foreach(client => {

          val remoteActor = select(client.node, client.sym);

          val local: Array[Int] = ds.take(client.localDSSize.toInt);

          remoteActor ! SortData(local);

          while (true) {
            receive {
              case ReturnValues(list: Array[Int]) => {
                cPrint("Recieved sorted data from client");

              }
            }
          }

          def cPrint(msg: String) = {
            println(client.ip + ":" + client.port + ": " + msg)
          }

          Thread.sleep(10000);
        });
      }


    } catch {
      case e: Exception =>
        println("Exception: " + e.toString());
    }
  }

}
