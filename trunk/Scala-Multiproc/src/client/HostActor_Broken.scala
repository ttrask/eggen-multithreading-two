package client;
//package host
//
//import scala.collection.parallel._
//import scala.actors._
//import scala.actors.Futures._
//import scala.actors.Actor._
//import scala.actors.remote._
//import scala.io._
//import java.io.File
//import scala.actors.remote.RemoteActor._
//import main._;
//import rpc._;
//import rpc.ReturnThreadCount;
//import rpc.GenerateNumbers
//import rpc.ReturnValues
//import scala.annotation.serializable
//
//case class StartExecution(c: ClientInformation);
//
//object HostActor_Broken extends scala.App {
//
//  override def main(args: Array[String]): Unit = {
//    try {
//
//      var dsLocked: Boolean = false;
//      var datasetSize: Long = scala.math.pow(2, 26).toLong + 23;
//
//      var ds: Array[Int] = Array();
//
//      implicit def string2Int(s: String): Int = augmentString(s).toInt
//
//      def f(i: Int) = i;
//
//      val ClientList: Array[ClientInformation] = {
//
//        var list: List[ClientInformation] = List[ClientInformation]();
//
//        for (line <- Source.fromFile(new File("clients.txt")).getLines) {
//
//          val split: Array[String] = line.split(" ");
//
//          val client: ClientInformation = new ClientInformation();
//
//          client.sym = Symbol(split(0));
//          client.ip = split(1);
//          client port = f(split(2));
//
//          list ::= client;
//        }
//
//        list.toArray;
//
//      }
//
//      ClientList.foreach(client => {
//        def localDSSize: Long = {
//          if (client.clientID == ClientList.head.clientID) {
//
//            datasetSize / ClientList.size + datasetSize % ClientList.size;
//          } else
//            datasetSize / ClientList.size
//        }
//      	client.localDSSize = localDSSize;
//      })
//
//      def ActiveClients: Array[ClientInformation] = ClientList.filter(_.isAlive == true)
//
//      RemoteActor.classLoader = getClass().getClassLoader();
//
//      //      println("Client individual array size = " + size.toInt);
//      //      println("Client Array Count" + count);
//      //      println("Total Numbers generated by client = " + size * (count - 1))
//
//      val dataset = {
//
//        val dataSetGenerator = ClientList.map(client => scala.actors.Futures.future {
//
//          val host: HostForemanActor = new HostForemanActor();
//
//          host.start;
//
//          host !! StartExecution(client);
//
//        });
//
//        dataSetGenerator.map(future => future.apply())
//
//        //var ds: Array[Int] = dataSetGenerator.map(future => future.apply());
//
//        //dataSetGenerator(: _*);
//      }
//
//      println("Dataset Completed Generation");
//      println("Dataset size:" + dataset.size);
//
//      def SortClientData() = {
//
//        println("Sorting Dataset of size: " + ds.size);
//
//        val aliveClients: Array[ClientInformation] = ClientList.filter(_.isAlive == true)
//
//        aliveClients.foreach(client => {
//
//          val remoteActor = select(client.node, client.sym);
//
//          val local: Array[Int] = ds.take(client.localDSSize.toInt);
//
//          remoteActor ! SortData(local);
//
//          while (true) {
//            receive {
//              case ReturnValues(list: Array[Int]) => {
//                println("Recieved sorted data from client");
//
//              }
//            }
//          }
//
//          def cprint(msg: String) = {
//            println(client.ip + ":" + client.port + ": " + msg)
//          }
//
//          Thread.sleep(10000);
//        });
//      }
//
//      true;
//
//    } catch {
//      case e: Exception =>
//        println("Exception: " + e.toString());
//    }
//
//  }
//}
//
//class HostForemanActor extends Actor {
//
//  val maxIndividualArraySize: Long = scala.math.pow(2, 26).toLong;
//
//  def act() {
//    Actor.loop {
//      react {
//        case StartExecution(client: ClientInformation) => {
//
//          var generationsCompleted: Int = 0;
//
//          var localDS: Array[Int] = Array();
//
//          client.node = new Node(client.ip, client.port);
//          val remoteActor = select(client.node, client.sym);
//
//          var count: Int = (client.localDSSize / maxIndividualArraySize).toInt + 1;
//
//          val size: Long = {
//
//            if (client.localDSSize > maxIndividualArraySize) {
//
//              client.localDSSize / count;
//
//            } else
//              client.localDSSize;
//          }
//
//          remoteActor ! IsAlive();
//
//          receive {
//            //once the remote actor says that they're alive, trigger the generation.
//            case ReturnThreadCount(threadCount: Int) =>
//              {
//                println("Registered client " + client.sym + " on " + client.ip + ":" + client.port);
//
//                client.isAlive = true;
//
//                client.threadCount = threadCount;
//
//                println("Client is alive with Thread count=" + threadCount);
//
//                var totalSize: Long = client.localDSSize;
//
//                println("Generating Numbers");
//
//                remoteActor ! GenerateNumbers(
//                  {
//                    (size + totalSize % count).toInt
//                  },
//                  scala.math.pow(2, 20).toInt);
//
//              }
//
//            case ReturnValues(list: Array[Int]) =>
//
//              println("Adding Array of size:" + list.size + " to dataset.");
//
//              localDS = localDS ++ list;
//
//              println("Dataset size: " + localDS.size);
//              generationsCompleted = generationsCompleted + 1;
//              println("Generations Complete: " + generationsCompleted + " of " + count);
//
//              if (generationsCompleted < count)
//                remoteActor ! GenerateNumbers(
//                  {
//                    (size).toInt
//                  },
//                  scala.math.pow(2, 20).toInt);
//              else {
//                println("Returning local dataset");
//                reply(localDS);
//              }
//
//              //                var isAdded = false
//              //
//              //                while (!isAdded) {
//              //                  if (!dsLocked) {
//              //                    dsLocked = true;
//              //                    ds = ds ++ localDS;
//              //                    dsLocked = false;
//              //                    isAdded = true;
//              //                  } else
//              //                    Thread.sleep(1000);
//              //                }
//              //
//              //                Thread.sleep(1000);
//              //                def sum(xs: List[Array[Int]]): Int = {
//              //
//              //                  def inner(xs: List[Array[Int]], accum: Int): Int = {
//              //                    xs match {
//              //                      case x :: tail => inner(tail, accum + x.size)
//              //                      case Nil => accum
//              //                    }
//              //                  }
//              //                  inner(xs, 0)
//              //                }
//              //
//              //                var generatedSize = ds.size;
//              //
//              //                println("Dataset total size: " + generatedSize)
//              //                println("Requested dataset size:" + datasetSize)
//              //
//              //                client.GenerationComplete = true;
//              //
//              //                println("Number of Completed Clients: " + ClientList.filter(_.GenerationComplete == true).size)
//              //                println("Number of Active Clients: " + ActiveClients.size)
//              //                
//              //                while (!dsLocked && !client.SortingComplete && ClientList.filter(_.GenerationComplete == true).size == ActiveClients.size) {
//              //                  println("Attempting to Sort Data");
//              //
//              //                  if (!dsLocked) {
//              //                    dsLocked = true;
//              //                    SortClientData();
//              //                    client.SortingComplete = true;
//              //                    Thread.sleep(1000);
//              //                  }
//              //                }
//              //                if //(ActiveClients.size < ClientList.size) {
//              //                (false) {
//              //                  //if all of the clients didn't get started
//              //                  // do something to spread the work around some.
//              //                } else {
//              //
//              //                }
//
//              //do something with the returned values.
//              //prepends the client ip:port to all print statements
//              def cprint(msg: String) = {
//                println(client.ip + ":" + client.port + ": " + msg)
//              }
//          }
//        }
//        case _ => exit()
//      }
//    }
//  }
//}
//
//class ClientInformation {
//  var SortingComplete: Boolean = false;
//  var GenerationComplete: Boolean = false;
//  val clientID = System.currentTimeMillis;
//  var SendData: Boolean = false;
//  var node: Node = null;
//  var sym: Symbol = null;
//  var ip: String = null;
//  var port: Int = 0;
//  var isAlive = false;
//  var threadCount: Int = 0;
//  var localDSSize: Long = 0;
//}